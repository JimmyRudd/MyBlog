---
layout: default
title: 反编译和打包
---  
##工具篇  

###apktool  
1. apk反编译工具，相当于普通反编译工具的集成，可以将dex转化为smali文件，将二进制的AndroidManifest.xml逆向回可读格式，同时逆向资源文件resources.arsc。修改完后可以重新打包回apk  
2. 不同jdk版本编译生成的apk，需要用到不同版本的apktool来反编译。（jdk1.7对应用apktool_2.0.0rc3)  
3. 更换apktool.jar后仍无法反编译，抛出异常中包含framework\1.apk的，删除user目录下的apktool\framework\1.apk 
4. apktool反编译不稳定，不可过分依靠  

###baksmali  
DEX的逆向工具，可以将apk压缩包中的classes.dex文件反编译成smali文件，·注意apktool反编译和baksmali反编译生成的smali格式不同，不能互相替换。

`想混合apktool使用，可以先用baksmali修改smali文件，之后生成dex文件替换回apk中，然后再用apktool反编译`  

###baksmali  
将smali文件重新生成dex文件  
  
###dex2jar  
DEX的逆向工具，可以将apk压缩包中的classes.dex文件转换成jar文件    

###jd-gui  
可以查看jar文件的反编译工具  

***
  
##命令篇

### 打包流程图
![auto package](http://i.stack.imgur.com/9pVaK.png  "auto package")  

###一.aapt(Android Asset Packaging Tool)  

####功能介绍
1. 列出压缩文件目录  

	aapt l[ist] [-v] [-a] file.{zip,jar,apk}  

2. 查看apk详细信息  

	aapt dump badging <file_path.apk>//查看apk包的label and icon、packageName、versionCode、applicationLabel、launcherActivity、permission等各种详细信息  

	aapt dump permissions <file_path.apk>//查看权限  

	aapt dump resources <file_path.apk> > XXX.txt //查看资源列表,输出到指定文件  

	aapt dump configurations <file_path.apk>//查看apk配置信息  

	aapt dump xmltree <file_path.apk> res/***.xml//以树形结构输出的xml信息。  

	aapt dump xmlstrings <file_path.apk> res/***.xml//输出xml文件中所有的字符串信息。  

3.生成R.java文件和(`自动打包和二次打包修改资源`)  

生成R.java文件  

配合apktool使用时,修改资源文件后,通过aapt命令重新生成对应的R.java文件(但要注意smali文件中已经存在的R.java的id对应地址数值。反编译思路也可以先从资源文件中的字符串入手，然后找R文件中该id对应的地址值，然后通过搜索地址值定位到引用该资源id的位置)  
 	
	aapt package -f -m -J %GEN% -S %RES% -I %ANDROID_JAR% -M %ANDROID_MANIFEST_XML%//生成R.java文件  

	%GEN%:存放生成的R.java文件夹路径。  
	%RES:res文件夹路径。  
	%ANDROID_JAR:引用的android.jar路径。  （在build-tools下選擇恰當的版本）
	%ANDROID_MANIFEST_XML:工程AndroidManifest.xml绝对路径。  

将资源文件编译成二进制文件  

	aapt package -f -M %ANDROID_MANIFEST_XML% -S %RES% -A %ASSETS% -I %ANDROID_JAR% -F %RESOURCE%  
		
	%ASSETS%:asset文件夹路径。  
	%RESOURCE%:生成的resouces.arsc存放路径。  

重新生成R文件后，需要根据AndroidManifest.xml里面的默认包路径，删除该路径下原来的旧文件，将R文件复制到该路径下（或者修改默认包名，使新生成的R文件放到新的路径下，如由原来的com.xx.x改为con.xx.x.a，但要注意activity等组件的定义）  

####参考资料  

[aapt使用小结——via:Sodino](http://blog.csdn.net/sodino/article/details/6122665)  
[命令行开发、编译、打包Android应用程序](http://www.cnblogs.com/wujd/archive/2012/01/10/wujiandong-android-1.html)  
[使用ANT打包Android应用——via:liuhe688](http://blog.csdn.net/liuhe688/article/details/6679879)  

###二.dx  

####功能介绍  

将.class字节码（bytecode）转换为Android字节码（保存在.dex文件中）  

	dx --dex --output=<要生成的classes.dex路径> <要处理的类文件的路径>  

####DEX文件介绍  

>   在Android系统中，一个App的所有代码都在一个Dex文件里面。Dex是一个类似Jar的存储了多有Java编译字节码的归档文件。因为Android系统使用Dalvik虚拟机，所以需要把使用Java Compiler编译之后的class文件转换成Dalvik能够执行的class文件。这里需要强调的是，Dex和Jar一样是一个归档文件，里面仍然是Java代码对应的字节码文件。当Android系统启动一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文件的效率要高很多。但是在早期的Android系统中，DexOpt有一个问题，也就是这篇文章想要说明并解决的问题。DexOpt会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个`链表的长度是用一个short类型来保存的，导致了方法id的数目不能够超过65536个`。  

####注意事项  

1. 必須先使用javac生成相關的.class文件    
2. dx命令在ANDROID_HOME/build-tools/VERSION/目录下，注意要选择比编译java文件高的build-tools。  
3.  dx处理的应该是javac生成的.classes文件  
4. 执行dx时最好在<要处理的类文件的路径>,因为<要处理的类文件的路径>必须和包路径一致（即com.a.b.c.class要对应com/a/b/c.class）  ，`否则会提示class name (xxx) does not match path (xxxx)`,同时默认包路径下没有R文件会提示`软件包 R 不存在`，缺少classpath设置android.jar会提示`软件包 android.util 不存在`  
5. <要处理的类文件的路径>可以使用正则表达式，如./*  

[dex解决Dex超出方法数的限制问题,让你的应用不再爆棚](http://blog.csdn.net/t12x3456/article/details/40837287)  



###三.javac  

####功能介绍  

用于编译java源码文件，由.java类文件生成class文件  

	javac [option] source  
	[option]:可选项，source 指Java源文件名,包括文件扩展名.java  
	eg.
	javac -source 1.6 -target 1.6 -encoding UTF-8 -d %OUTPUT_DIR% %SOURCE% -bootclasspath %ANDROID_JAR%  

	javac [ options ] [ sourcefiles ] [ @files ]
	可以用'@' 字符加上包含有要编译java源文件名的文件名来指定要编译的java源文件。因为javac当遇到以 `@' 字符，它就会对该字符后的文件所列出的所有java源文件进行编译  

>** 选项说明**   

>-g                         生成所有调试信息  

>-g:none                    不生成任何调试信息  

>-g:{lines,vars,source}     只生成某些调试信息  

>-nowarn                    不生成任何警告  

>-verbose                   输出有关编译器正在执行的操作的消息  

>-deprecation               输出使用已过时的 API 的源位置  

>-classpath <路径>            指定查找用户类文件和注释处理程序的位置  

>-cp <路径>                   指定查找用户类文件和注释处理程序的位置  

>-sourcepath <路径>           指定查找输入源文件的位置  

>-bootclasspath <路径>        覆盖引导类文件的位置  

>-extdirs <目录>              覆盖安装的扩展目录的位置  

>-endorseddirs <目录>         覆盖签名的标准路径的位置  

>-proc:{none,only}          控制是否执行注释处理和/或编译。  

>-processor <class1>[,<class2>,<class3>...]要运行的注释处理程序的名称；绕过默认的搜索进程  

>-processorpath <路径>        指定查找注释处理程序的位置  

> -d <目录>                    指定存放生成的类文件的位置，若未指定 -d 选项，则 javac 将把类文件放到与源文件相同的目录中。  

> -s <目录>                    指定存放生成的源文件的位置  

>-implicit:{none,class}     指定是否为隐式引用文件生成类文件   

> -encoding <编码>             指定源文件使用的字符编码  

>-source <版本>               提供与指定版本的源兼容性  

>-target <版本>               生成特定 VM 版本的类文件  

> -version                   版本信息  

>-help                      输出标准选项的提要  

>-Akey[=value]              传递给注释处理程序的选项  

>-X                         输出非标准选项的提要  

>-J<标志>                     直接将 <标志> 传递给运行时系统  


####注意事项  

1. 必須先使用aapt生成對應的R.java文件（并将其放到需要编译的源文件目录中AndroidManifest.XML中声明的默认包路径下。可以将源文件和aapt生成的R文件按照对应包路径放到一个新建目录下。否则执行dx时会提示`找不到R文件`）       
2. -classpath该选项可以引入需要引入的第三方库jar(如android-support-v4.jar)  


####参考资料  
[javac命令详解](http://blog.csdn.net/hudashi/article/details/7058998)  
  



###四.jarsigner   

####功能介绍  

签名和验证工具，使用来自keystore秘钥仓库的秘钥和证书信息为apk生成数字签名。  
`keystore秘钥仓库`:由私钥及其相关的X509证书链(用于鉴别相应公钥)组成的数据库。使用`keytool`来创建和管理秘钥仓库  
  

	用法：
	jarsigner [选项] jar 文件别名//签名  
	jarsigner -verify [选项] jar 文件//验证签名  

	jarsigner -verbose -keystore %KEYSTORE% -storepass %STOREPASS% -signedjar %SIGNED_APK% %UNSIGNED_APK% $ALIASNAME  
	
	%KEYSTORE%	秘钥仓库路径  
	%STOREPASS%	秘钥仓库密码  
	%SIGNED_APK% 生成签名apk保存路径  
	%UNSIGNED_APK% 未签名apk路径  
	$ALIASNAME	秘钥仓库别名  


**选项说明**   

>[keystore <url>]           密钥库位置  

>[-storepass <口令>]         用于密钥库完整性的口令  

>[-storetype <类型>]         密钥库类型  

>[-keypass <口令>]           专用密钥的口令（如果不同）  

>[-sigfile <文件>]           .SF/.DSA 文件的名称  

>[-signedjar <文件>]         已签名的 JAR 文件的名称  

>[-digestalg <算法>]    摘要算法的名称  

>[-sigalg <算法>]       签名算法的名称  

>[-verify]                   验证已签名的 JAR 文件  

>[-verbose]                  签名/验证时输出详细信息  

>[-certs]                    输出详细信息和验证时显示证书  

>[-tsa <url>]                时间戳机构的位置  

>[-tsacert <别名>]           时间戳机构的公共密钥证书  

>[-altsigner <类>]           替代的签名机制的类名  

>[-altsignerpath <路径列表>] 替代的签名机制的位置  

>[-internalsf]               在签名块内包含 .SF 文件  

>[-sectionsonly]             不计算整个清单的散列  

>[-protected]                密钥库已保护验证路径  

>[-providerName <名称>]      提供者名称  

>[-providerClass <类>        加密服务提供者的名称  

>[-providerArg <参数>]] ... 主类文件和构造函数参数  


####参考资料  

[JDK工具jarsigner用法详解](http://www.softown.cn/post/173.html)  
[Android签名详解](http://www.cnblogs.com/xiwix/archive/2012/04/15/2447910.html)  


###五.zipalign   

####功能介绍  

档案整理工具，让所有未压缩数据以整合报形式整理到4字节界层(apk可看成压缩包zip，align为对齐的意思，由命令名也可以看出其中对齐的含义),整理后可提高ANDROID操作系统和应用之间交互效率、提高运行速度、减少占用内存。  

最根本目的是帮助操作系统更高效率的根据请求索引资源，将resource-handling code统一将Data structure alignment（数据结构对齐标准：DSA）限定为4-byte boundaries。  

zipalign操作必须在签名之后，否则签名过程会干扰zipalign结果  

	zipadlign -v 4 %ZIPALIGN_APK% %UNZIPALIGN_APK%  
  
>**选项说明**  

-f—重写存在的outfile.zip   
-v—提供详细的输出   
-c—确认一个给定的文件的整理  
>  

####参考资料  

[什么是Zipalign？什么是Zipaligned？](http://bbs.ihei5.com/thread-171596-1-1.html)  
[Android签名详解](http://www.cnblogs.com/xiwix/archive/2012/04/15/2447910.html)  

###六.keystore   

####功能介绍  

秘钥和数字证书管理工具，所创建的`证书以别名形式`存放在证书库(keystore)中，证书库中的一条`证书包含私钥，公钥和对应主体信息`。导出数字证书文件只包含`主体信息和对应公钥`    

	keytool	-genkey -v -keystore liufeng.keystore -alias liufeng.keystore -keyalg RSA -validity 20000  
说明：  
      1）keytool是工具名称，-genkey意味着执行的是生成数字证书操作，-v表示将生成证书的详细信息打印出来，显示在dos窗口中；  
      2）-keystore liufeng.keystore 表示生成的数字证书的文件名为"liufeng.keystore"；  
      3）-alias liufeng.keystore 表示证书的别名为"liufeng.keystore"，当然可以不和上面的文件名一样；  
      4）-keyalg RSA 表示生成密钥文件所采用的算法为RSA；  
      5）-validity 20000 表示该数字证书的有效期为20000天，意味着20000天之后该证书将失效  
在执行上面的命令生成数字证书文件时，会提示你输入一些信息，包括证书的密码。  

>**选项说明**  

>-genkey 在用户主目录中创建一个默认文件”.keystore”,还会产生一个mykey的别名，mykey中包含用户的公钥、私钥和证书(在没有指定生成位置的情况下,keystore会存在用户系统默认目录)  

>-alias 产生别名 每个keystore都关联这一个独一无二的alias，这个alias通常不区分大小写  

>-keystore 指定密钥库的名称(产生的各类信息将不在.keystore文件中)  

>-keyalg 指定密钥的算法 (如 RSA DSA，默认值为：DSA)  

>-validity 指定创建的证书有效期多少天(默认 90)  

>-keysize 指定密钥长度 （默认 1024）  

>-storepass 指定密钥库的密码(获取keystore信息所需的密码)  

>-keypass 指定别名条目的密码(私钥的密码)  

>-dname 指定证书发行者信息 其中： “CN=名字与姓氏,OU=组织单位名称,O=组织名称,L=城市或区域名 称,ST=州或省份名称,C=单位的两字母国家代码”  

>-list 显示密钥库中的证书信息 keytool -list -v -keystore 指定keystore -storepass 密码  

>-v 显示密钥库中的证书详细信息  

>-export 将别名指定的证书导出到文件 keytool -export -alias 需要导出的别名 -keystore 指定keystore -file 指定导出的证书位置及证书名称 -storepass 密码  

>-file 参数指定导出到文件的文件名  

>-delete 删除密钥库中某条目 keytool -delete -alias 指定需删除的别 -keystore 指定keystore – storepass 密码  

>-printcert 查看导出的证书信息 keytool -printcert -file g:\sso\michael.crt  

>-keypasswd 修改密钥库中指定条目口令 keytool -keypasswd -alias 需修改的别名 -keypass 旧密码 -new 新密码 -storepass keystore密码 -keystore sage  

>-storepasswd 修改keystore口令 keytool -storepasswd -keystore g:\sso\michael.keystore(需修改口令的keystore) -storepass pwdold(原始密码) -new pwdnew(新密码)  

>-import 将已签名数字证书导入密钥库 keytool -import -alias 指定导入条目的别名 -keystore 指定keystore -file 需导入的证书  

####参考资料  

[Android签名详解](http://www.cnblogs.com/xiwix/archive/2012/04/15/2447910.html)  
[java keytool证书工具使用小结](http://www.micmiu.com/lang/java/keytool-start-guide/)  



###七.apkbuilder   

####功能介绍  
  
android打包脚本,android3.0之后被删除，实际执行的是com.android.sdklib.build.ApkBuilderMain这个类，所以可以自行实现（ant脚本）  

	<java classpath="${android.tools}/lib/sdklib.jar" classname="com.android.sdklib.build.ApkBuilderMain">  
		<arg value="${path.build.main}/bin/unsigned.apk" />    
		<arg value="-u" />    
		<arg value="-z" />    
		<arg value="${path.build.main}/bin/res.zip" />  
		<arg value="-f" />  
		<arg value="${path.build.main}/bin/classes.dex" />  
		<arg value="-rf" />  
		<arg value="${path.build.main}/src" />  
		<arg value="-rj"/>  
		<arg value="${path.build.main}/libs"/>  
		<arg value="-nf"/>  
		<arg value="${path.build.native}"/>  
	</java>  
	
	
####参考资料  

[apkbuilder找不到了！！！](http://blog.csdn.net/a85907468/article/details/27224061)  


##自动化构建工具篇  

###一.Ant     


	
